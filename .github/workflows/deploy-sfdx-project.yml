permissions:
  contents: write

on:
  workflow_call:
    inputs:
      git-deploy-tag:
        type: string
        description: Optional git tag to apply to the deployed commit (e.g. dev, uat, prod)
        required: false
      source-directory:
        type: string
        description: Directory containing the main source of the project. Usually force-app, but can be something else. This is used to determine which entry in packageDirectories in sfdx-project.json is the main one. Defaults to force-app.
        required: false
        default: force-app
      sonar-url:
        type: string
        description: URL of the Sonar server to use for analyzing the code. If omitted, no Sonar analysis will be run.
        required: false
      sonar-login-encrypted:
        type: string
        description: Ansible Vault-encrypted access token or username:password combination for the Sonar server specified in the `sonar-url` input. (This should be encrypted using ansible-vault encrypt, NOT ansible-vault encrypt_string!)
        required: false
        default: |
          $ANSIBLE_VAULT;1.1;AES256
          32383833326465363461613034373735353061326462373665653330313132316435373132333230
          3039643535343833333336306339376265363837383233370a313866313130373936396565643862
          66383061666138303463306435303236646137623634396662646232343837353731636665633961
          3465333431326532360a373035396232353032353236313165376138343463343539636632373139
          33393861363331373862366339663363353436623765316164303932303666626635336632633065
          3539363134663136646165386566353962326664643833353464
      sonar-quality-gate:
        type: boolean
        description: Whether to poll the SonarQube instance until the quality gate status is available and fail the build if the quality gate fails.
        required: false
        default: false
      instance-url:
        type: string
        description: Salesforce instance URL of the target org
        required: true
      client-id:
        type: string
        description: OAuth client ID (sometimes called consumer key) of the connected app on Salesforce used to connect to the target org
        required: true
      jwt-key-encrypted:
        type: string
        description: Ansible Vault-encrypted private key to connect to the target org with using the JWT flow. (This should be encrypted using ansible-vault encrypt, NOT ansible-vault encrypt_string!)
        required: true
      username:
        type: string
        description: Username of Salesforce user to authenticate as on the target org
        required: true
      run-tests:
        type: boolean
        description: Whether to run tests as part of the deployment. This is required when deploying to a production org.
        required: true
      docker-username:
        type: string
        description: Username to use to connect to the docker registry docker.wtax.co that contains the wtax/pmd image used for static code analysis
        required: false
        default: github
      docker-password-encrypted:
        type: string
        description: Ansible Vault-encrypted password matching the `docker-username` used to log in to the Docker registry docker.wtax.co. This should be encrypted using ansible-vault encrypt, NOT ansible-vault encrypt_string!
        required: false
        default: |
          $ANSIBLE_VAULT;1.1;AES256
          63353733303166336136366435326436353731376636366631396239656432326433393265663965
          3736366139386466646534633963346133396333376333380a343032326335623566626263623062
          66646433313964633930383465626633666636633937303839306266346562316230643965373633
          6365326631316564640a626466666634333235656163333334373538663534323862303733353664
          63626230363462643364393731616137393231653866363230636238393266363430
      destructive-changes-after-deployment:
        type: boolean
        description: Instruct Salesforce to apply destructive changes (i.e. deletes) after the deployment. This is the default. In some cases you may want to apply destructive changes before deploying. In that case, set this input to false.
        required: false
        default: true
      environment:
        type: string
        description: The name of a GitHub deployment environment in the repository that determines which deployment protection rules, such as reviews, will apply to this deployment.
        required: false
      running-environment:
        type: string
        description: The name of the deployment environment in the repository that the workflow is being called from. This is used to create unique upload artifact names when this reusable workflow is called from different jobs in the same calling workflow.
        required: false
      metadata-artifact:
        type: string
        description:
          The name of a previously uploaded artifact containing the metadata to deploy.
          If omitted, the workflow generates one automatically.
          If set, deletes-artifact and test-classes-artifact must also be specified.
        required: false
      test-classes-artifact:
        type: string
        description:
          The name of a previously uploaded artifact containing a test-classes.txt file with the names of Apex test
          classes in the metadata, one class per line.
          If omitted, the workflow generates one automatically.
          If set, metadata-artifact and deletes-artifact must also be specified.
        required: false
      deletes-artifact:
        type: string
        description:
          The name of a previously uploaded artifact containing a deletes.csv file with metadata to delete.
          If omitted, the workflow generates one automatically.
          If set, metadata-artifact and test-classes-artifact are also required.
        required: false
    secrets:
      ansible-vault-password:
        description: Password to be used to decrypt the `jwt-key-encrypted`.
        required: true

jobs:
  build:
    if: inputs.metadata-artifact == ''
    uses: wtaxco/wtax-github-actions-workflows/.github/workflows/build-sfdx-project.yml@main
    with:
      run-compile-and-test: false
    secrets:
      ansible-vault-password: ${{ secrets.ansible-vault-password }}

  deploy:
    needs: [ build ]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    # Temporary: always() is used for backward compatibility with legacy build+deploy workflows.
    # Remove once the unified single-deployment pipeline is in place.
    if: ${{ always() && (inputs.metadata-artifact != '' || needs.build.result == 'success') }}
    steps:
      - name: check out code
        uses: actions/checkout@v4

      - name: install jq
        run: sudo apt-get install -y jq

      - name: set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18.x

      - name: install Salesforce CLI
        run: npm list -g @salesforce/cli || npm install -g @salesforce/cli && npm list -g @salesforce/cli

      - name: create unsigned plugin allowlist
        run: |
          mkdir -p $HOME/.config/sf
          echo '[ "apex-code-coverage-transformer" ]' > $HOME/.config/sf/unsignedPluginAllowList.json

      - name: write Ansible Vault password to file
        run: echo "${{ secrets.ansible-vault-password }}" >.vault-password

      - name: write encrypted JWT key to file
        run: echo '${{ inputs.jwt-key-encrypted }}' >.jwt-key

      - name: decrypt the private key for the Continuous Integration connected app
        run: ansible-vault decrypt --vault-password-file=.vault-password .jwt-key

      - name: connect to org
        run: |
          sf auth jwt grant \
            --client-id="${{ inputs.client-id }}" \
            --jwt-key-file=.jwt-key \
            --instance-url=${{ inputs.instance-url }} \
            --username=${{ inputs.username }} \
            --set-default

      - name: List artifacts
        run: ls -R target || true

      - name: download metadata ZIP file (from input)
        if: ${{ inputs.metadata-artifact != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.metadata-artifact }}
          path: target/${{ github.event.repository.name }}

      - name: download deleted metadata CSV file (from input)
        if: ${{ inputs.deletes-artifact != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.deletes-artifact }}
          path: target

      - name: download test classes file (from input)
        if: ${{ inputs.test-classes-artifact != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.test-classes-artifact }}
          path: target

      - name: download metadata ZIP file (from build output)
        if: ${{ inputs.metadata-artifact == '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.metadata-artifact }}
          path: target/${{ github.event.repository.name }}

      - name: download deleted metadata CSV file (from build output)
        if: ${{ inputs.deletes-artifact == '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.deletes-artifact }}
          path: target

      - name: download test classes file (from build output)
        if: ${{ inputs.test-classes-artifact == '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.test-classes-artifact }}
          path: target

      - name: do destructive changes before deployment
        run: |
          echo destructiveChangeManifestFile=destructiveChangesPre.xml >>$GITHUB_ENV
          echo destructiveChangeType=pre >>$GITHUB_ENV
        if: ${{ !inputs.destructive-changes-after-deployment }}

      - name: do destructive changes after deployment
        run: |
          echo destructiveChangeManifestFile=destructiveChangesPost.xml >>$GITHUB_ENV
          echo destructiveChangeType=post >>$GITHUB_ENV
        if: inputs.destructive-changes-after-deployment

      - name: create destructive change manifest for components marked for deletion
        run: |
          echo "Creating destructive change manifest for components marked for deletion"
          
          # Set some variables
          target_org="${{ inputs.username }}"
          
          # Get list of components on org
          echo "- Getting list of components on org"
          sf data query -t -o ${target_org} -q 'SELECT Name FROM ApexClass' --json | jq -r '.result.records[].Name' > target/org-apex-classes.txt
          sf data query -t -o ${target_org} -q 'SELECT Name FROM ApexTrigger' --json | jq -r '.result.records[].Name' > target/org-apex-triggers.txt
          sf data query -t -o ${target_org} -q 'SELECT Name FROM ApexPage' --json | jq -r '.result.records[].Name' > target/org-apex-pages.txt
          sf data query -t -o ${target_org} -q 'SELECT Name FROM ApexComponent' --json | jq -r '.result.records[].Name' > target/org-apex-components.txt
          sf data query -o ${target_org} -q 'SELECT Name FROM Network' --json | jq -r '.result.records[].Name' > target/org-networks.txt
          sf data query -o ${target_org} -q 'SELECT Name FROM Site' --json | jq -r '.result.records[].Name' > target/org-sites.txt
          sf data query -o ${target_org} -q 'SELECT DeveloperName FROM FlowDefinition' --usetoolingapi --json | jq -r '.result.records[].DeveloperName' > target/org-flows.txt
          
          # Move components that still exist on org to delete/source
          echo - Filtering components that still exist on org
          >target/scheduled-for-destruction.txt
          >target/already-destroyed.txt
          >target/cannot-destroy.txt
          awk -F, '{print "type=\""$2"\" fullName=\""$3"\""}' target/deletes.csv|while read line; do
            eval $line
            if [ "$type" == "ApexClass" ]; then
              if grep "^${fullName}\$" target/org-apex-classes.txt; then
                echo "    Scheduling ${type}:${fullName} for destruction"
                echo "${type}:${fullName}" >>target/scheduled-for-destruction.txt
              else
                echo "${type}:${fullName}" >>target/already-destroyed.txt
              fi
            elif [ "$type" == "ApexTrigger" ]; then
              if grep "^${fullName}\$" target/org-apex-triggers.txt; then
                echo "    Scheduling ${type}:${fullName} for destruction"
                echo "${type}:${fullName}" >>target/scheduled-for-destruction.txt
              else
                echo "${type}:${fullName}" >>target/already-destroyed.txt
              fi
            elif [ "$type" == "ApexPage" ]; then
              if grep "^${fullName}\$" target/org-apex-pages.txt; then
                echo "    Scheduling ${type}:${fullName} for destruction"
                echo "${type}:${fullName}" >>target/scheduled-for-destruction.txt
              else
                echo "${type}:${fullName}" >>target/already-destroyed.txt
              fi
            elif [ "$type" == "ApexComponent" ]; then
              if grep "^${fullName}\$" target/org-apex-components.txt; then
                echo "    Scheduling ${type}:${fullName} for destruction"
                echo "${type}:${fullName}" >>target/scheduled-for-destruction.txt
              else
                echo "${type}:${fullName}" >>target/already-destroyed.txt
              fi
            elif [ "$type" == "Network" ]; then
              if grep "^${fullName}\$" target/org-networks.txt; then
                echo "    Scheduling ${type}:${fullName} for destruction"
                echo "${type}:${fullName}" >>target/scheduled-for-destruction.txt
              else
                echo "${type}:${fullName}" >>target/already-destroyed.txt
              fi
            elif [ "$type" == "Site" ]; then
              if grep "^${fullName}\$" target/org-sites.txt; then
                echo "    Scheduling ${type}:${fullName} for destruction"
                echo "${type}:${fullName}" >>target/scheduled-for-destruction.txt
              else
                echo "${type}:${fullName}" >>target/already-destroyed.txt
              fi
            elif [ "$type" == "Flow" ]; then
              if grep "^${fullName}\$" target/org-flows.txt; then
                echo "    Scheduling ${type}:${fullName} for destruction"
                echo "${type}:${fullName}" >>target/scheduled-for-destruction.txt
              else
                echo "${type}:${fullName}" >>target/already-destroyed.txt
              fi
            else
              echo "${type}:${fullName}" >>target/cannot-destroy.txt
              echo "    WARNING: Support for deleting components of metadata type ${type} not implemented yet (${type}:${fullName})."
            fi
          done
          
          scheduled_for_destruction=$(wc -l <target/scheduled-for-destruction.txt)
          already_destroyed=$(wc -l <target/already-destroyed.txt)
          cannot_destroy=$(wc -l <target/cannot-destroy.txt)
          echo "${scheduled_for_destruction} component(s) to be deleted from org, ${already_destroyed} already deleted (cannot delete ${cannot_destroy})."
          if [ ${scheduled_for_destruction} -gt 0 ]; then
            echo "- Generating destructive change manifest..."
            metadata_args=$(cat target/scheduled-for-destruction.txt|while read line; do echo -n "--metadata ${line} "; done)
            sf project generate manifest ${metadata_args} --type ${destructiveChangeType} --output-dir=target/${{ github.event.repository.name }}
            echo "Ok! Added ${scheduled_for_destruction} destructive changes to target/${{ github.event.repository.name }}/${destructiveChangeManifestFile}."
          else
            echo "No destructive changes to add."
            cat <<EOF >target/${{ github.event.repository.name }}/${destructiveChangeManifestFile}
          <?xml version="1.0" encoding="UTF-8"?>
          <Package xmlns="http://soap.sforce.com/2006/04/metadata" />
          EOF
          fi
          echo

      - name: deploy to org and run Apex tests
        run: |
          timeout=180
          testflags=$(cat target/test-classes.txt | while read testClass; do
            echo -n "--tests=${testClass} "
          done)
          echo "Deploying to ${{ inputs.username }} and running unit tests... (timeout ${timeout} minutes)"
          sf project deploy start \
            --target-org="${{ inputs.username }}" \
            --test-level=RunSpecifiedTests ${testflags} \
            --coverage-formatters=json \
            --results-dir=reports/deploy-coverage \
            --metadata-dir="target/${{ github.event.repository.name }}" \
            --wait=${timeout}

      - name: tag deployed commit
        if: ${{ inputs.git-deploy-tag != '' }}
        run: |
          git fetch --tags
          git tag -f "${{ inputs.git-deploy-tag }}" "$GITHUB_SHA"
          git push origin "${{ inputs.git-deploy-tag }}" --force

      - name: check if deploy-coverage artifact exists
        id: check_artifact
        run: |
          existing=$(gh run-artifact list --limit 100 | grep '^deploy-coverage$' || true)
          if [ -n "$existing" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: upload deploy-coverage artifact
        if: ${{ steps.check_artifact.outputs.exists == 'false' }}
        uses: actions/upload-artifact@v4
        with:
          name: deploy-coverage
          path: reports/deploy-coverage

  sonar_and_pmd:
    if: ${{ always() && inputs.sonar-url != '' }}
    uses: wtaxco/wtax-github-actions-workflows/.github/workflows/sonar-and-pmd.yml@main
    needs: deploy
    with:
      sonar-code-coverage-report: "reports/deploy-coverage"
      sonar-url: ${{ inputs.sonar-url }}
      source-directory: ${{ inputs.source-directory }}
      docker-username: ${{ inputs.docker-username }}
      docker-password-encrypted: ${{ inputs.docker-password-encrypted }}
      sonar-login-encrypted: ${{ inputs.sonar-login-encrypted }}
      sonar-quality-gate: ${{ inputs.sonar-quality-gate }}
    secrets:
      ansible-vault-password: ${{ secrets.ansible-vault-password }}